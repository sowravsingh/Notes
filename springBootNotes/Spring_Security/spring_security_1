


                                                                                               Different Security Attacks


          There    are different security attacks	

    (1) CSRF Attack    (Cross Site Request Forgery)

                                It is a attack where a user was already authenticated to an origin but    hacker makes unwanted request to that origin without intervention of user but with user’s session details.
 
                              Let’s consider session base authentication

                            Here User will be login in one banking website (bank.com) he has authenticated by bank and he got session id for his browser and he is using it .
                            So from now whenever user make any request from this browser to that bank site browser will automatically send session details along with that request.
                            Mean time user might click any link in another tab (evil.com) and it is hack link .
                            As soon as he click on the link. In that link it internally calls the banking site and make any request to deduct amount .
                            as browser will automatically sends session details to that bank site it doesn’t care from which origin this    url was hit    so this request will get authenticated and it will get processed.


          So this attack can be prevented by many process among them few are 

        (1)    use same site cookies 
        
                  We can set cookie policies like ::
                    Set-Cookie: JSESSIONID=xyz; SameSite=Strict; Secure; HttpOnly

            This will prevent browser from sending cookies with cross site requests as here origin is evil.com so if request was made from other than origin site browser will not send automatically session details.


    (2) using csrf token :: 
            
          This is a unique and random token generated by server and it will embedded to every request .
        So while sending any request from client they need to send this csrf token also or else that request will not get processed.

      Browsers send cookies (like session IDs) to the server automatically but  Browsers do not let JavaScript read cookies from another site (because of Same-Origin Policy)
 



But using csrf token also some times fails as hacker might get token details with xss attack.


(2)    XSS Attack (Cross Site Scripting)

            It is an attack that hacker might inject any javasrcript into a web page and this script will be executed if any user loads that web page.    He might put anything in that script he might put something to fetch that csrf token of any user who might load that web page.

          Imagine there is a web page for a blog where user can add comments .
        Some user might add javascript as comment    which will access token of current using user.
        So next if any user open that page all the content will be loaded and also all the comments will be loaded at that time this script will get executed.



          In this way using xss attacker can read any users csrf token



          We can prevent this XSS attacks by    

      (1)    the injecting user data into html escape it.      
      (2)    sanitize the input.
      (3) use content security policy a    response header that controls which scripts are allowed to run.
      (4) Avoid returning	html from backend if not needed.


(3) CORS    (Cross Origin Resource Sharing) 

            It is something like I will allow	requests from which I trust.

        In serverside in backed we will set what are the origin from which requests were allowed :: 

                Access-Control-Allow-Origin: *

 Here if we put * from any origin we can make request to this url . So to prevent this instead of giving * we can mention only the origins that we trust.




(4) SQL Injection ::
 
                        It is an attack where hacker can inject any miscellaneous sql code to manipulate db .



Let’ss assume we are accepting username and password from client. If they sent we are hitting to db to get that user details . 

If we use parameterized query :: 
 
                String query = "SELECT * FROM users WHERE username = '" + username + "' AND password = '" + password + "'";
 
              Here we are directly putting data what we got from request    if hacker sends username    as admin and password as anything then he can get directly admin details.


So to prevent this attack use prepared statements instead of parematerized query . 


                  String sql = "SELECT * FROM users WHERE username = ? AND password = ?";
                  PreparedStatement pstmt = connection.prepareStatement(sql);
                pstmt.setString(1, username);
                pstmt.setString(2, password); 
                ResultSet rs = pstmt.executeQuery();


Now even if he sent password as anything it will treat anything as string and search for that password and so that hacker can’t get details as password was not matched instead of treating it a sql code.

So Never build SQL with string concatenation











                    

                                                                                                                                                                                                                                                                                                                                                                            Spring Security Architecture




We need to protect our resources from above attacks by implementing proper authorization    and authentication. For that we use spring security.


    As we know when we hit an api first it will go through tomcat    server from there filter chain (if we add any filters) from there to dispatcher servlet    from there to interceptor    and from there to controller	
    When    You implement spring security then security filter will be added in the filter chain. inside    that filter there will be again multiple security filters.

 We have many authentication methods like (Basic authentication , form based authentication (username / password), OATH2 ) . For all these methods they have their filters so based on which authentication method we choose only that filter will be executed not all other security filters.    


    So when a request comes it passes through filters when it goes into security filter there it goes to appropriate filter based on authentication method we are using , again from that filter it goes to Authentication manager (interface) with authenticate object (it has some fileds and is authenticate boolean flag) , this interface was implemented    by provider manager class so in there based on the filter and authentication method we are using it will pass this authenticate object to that respective providers .


All the logic will be executed here in that respective provider class based on the method we use . 

 For eg :: if we choose form based authentication then Daoauthetnicatuonprovider will be executing it will fetch username and password from db and compares it with user provided credentials. Once authentication    was done it will return back the same authenticate object back with authenticated is true.


If authentication was false it will throw exception from there itself . If it is success then this authenticate object will be stored in    security context and this security context will passed along with the request to further interceptor and from there to controller.


For sprinboot security we need to add dependency of springboot security in pom.xml

                                    <dependency>
	       <groupId>org.springframework.boot </groupId>
	       <artifactId>spring-boot-starter-security</artifactId>
      </dependency>














